# 内存模型

![image-20240803131152587](./assert/jvm/image-20240803131152587.png)

## 1. 程序计数器的作用，为什么是私有的？

作用是记录正在执行的虚拟机字节码指令的地址。

私用的原因是为了实现进程的切换。详细的再解释一下...

使用`javap -V xx.class` 命令来反编译字节码文件。

## 2. 你能详细的介绍一下java堆及其构成吗？

* java堆是虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域，在**虚拟机启动时创建**，主要用来存放对象实例和数组。

* 随着JVM的发展和不同垃圾收集器的实现，堆的具体划分可能会有所不同，但通常可以分为以下几个部分：

  ![image-20240803132704964](./assert/jvm/image-20240803132704964.png)

  * 新生代:新生代分为Eden Space和Survivor Space。在Eden Space中， 大多数新创建的对象首先存放在这里。Eden区相对较小，当Eden区满时，会触发一次Minor GC（新生代垃圾回收）。在Survivor Spaces中，通常分为两个相等大小的区域，称为S0（Survivor 0）和S1（Survivor 1）。在每次Minor GC后，存活下来的对象会被移动到其中一个Survivor空间，以继续它们的生命周期。这两个区域轮流充当对象的中转站，帮助区分短暂存活的对象和长期存活的对象。
  * 老年代（Old Generation/Tenured Generation）:经过一次或多次Minor GC仍存活的对象会被移动到老年代。老年代中的对象生命周期较长，因此Major GC（也称为Full GC，涉及老年代的垃圾回收）发生的频率相对较低，但其执行时间通常比Minor GC长。老年代的空间通常比新生代大，以存储更多的长期存活对象。
  * 元空间（Metaspace）:从Java 8开始，永久代（Permanent Generation）被元空间取代，用于存储类的元数据信息，如类的结构信息（如字段、方法信息等），静态变量，常量。编译后的代码。元空间并不在Java堆中，而是使用本地内存，这解决了永久代容易出现的内存溢出问题。
  * 大对象区（Large Object Space / Humongous Objects）:在某些JVM实现中（如G1垃圾收集器），为大对象分配了专门的区域，称为大对象区或Humongous Objects区域。大对象是指需要大量连续内存空间的对象，如大数组。这类对象直接分配在老年代，以避免因频繁的年轻代晋升而导致的内存碎片化问题。

## 3. 什么是虚拟机栈？

* 每个线程有一个私有的栈，随着线程的创建而创建。每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存，栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、动态链接、方法出口等信息，每个线程只能有一个活动栈帧，对应这当前正在执行的那个方法。栈的大小可以固定也可以动态扩展。

* 垃圾回收是否涉及栈内存？

  垃圾回收主要指堆内存，当栈帧弹出时，内存就会释放。

* 栈内存分配越大越好吗？

  未必，默认的栈内存通常为1024K，栈过大会导致线程数变小。

* 方法内的局部变量是否线程安全？

  * 如果方法内局部变量没有逃离方法的作用范围，他是线程安全的
  * 如果局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全

* 什么情况会导致栈内存溢出？

  《Java虚拟机规范》中，对了虚拟机栈的两类异常情况

  1. 如果线程请求的栈深度大于虚拟机允许的深度，将抛出StackOverflowError异常；
  2. 如果java虚拟机栈容量可以动态扩展，当栈扩展到无法申请足够的内存会抛出OutOfMemoryError异常。

  

  

## 4. 能不能解释一下方法区？

* 方法区是各个线程共享的内存区域，用来存储以被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等，虚拟机启动的时候创建，关闭虚拟机时释放。

class文件包含类基本信息、常量池、方法定义。

## 5. 介绍一下运行时常量池

常量池是*.class文件中的，当该类被加载，它的常量池信息就会放入**运行时常量池**，并把里面的**符号地址变为真实地址**。符号地址就是指#1、2、3那个，真实地址就是内存地址了

类基本信息：

![image-20240803141957321](./assert/jvm/image-20240803141957321.png)

方法定义：

![image-20240803142114952](./assert/jvm/image-20240803142114952.png)

（无参构造函数）

![image-20240803142138268](./assert/jvm/image-20240803142138268.png)

（mian方法）

常量池：

![image-20240803142306513](./assert/jvm/image-20240803142306513.png)

![image-20240803142349815](./assert/jvm/image-20240803142349815.png)

![image-20240803142413758](./assert/jvm/image-20240803142413758.png)

 ## 6. 你听过直接内存吗？

* 不是虚拟机运行时数据区的一部分，也不是jvm中的内存结构，不由jvm进行管理。是系统内存。

* 常见于NIO操作时，用于数据缓冲区，分配回收成本高，但读写性能高，不受JVM内存回收管理。

## 7. String保存在哪里呢？

## 8. String s = new String（“abc”）执行过程中分别对应哪些内存区域？

## 9.  引用类型有哪些？有什么区别？

## 10.  弱引用了解吗?举例说明在哪里可以用?

## 11. OOM发生在JVM的哪一块内存空间？

## 12.  jvm 内存结构有哪几种内存溢出的情况？

# 类初始化和类加载

## 13. 什么是类加载器。类加载器有哪些？

1. 类加载器是一个负责加载类的对象，他将字节码文件加载到jvm中，用于实现类加载过程中的加载这一步。
   * **类加载器的主要作用就是加载 Java 类的字节码（ `.class` 文件）到 JVM 中（在内存中生成一个代表该类的 `Class` 对象）。**

2. JVM 中内置了三个重要的 `ClassLoader`：
   1. **`BootstrapClassLoader`(启动类加载器)**：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ `%JAVA_HOME%/lib`目录下的 `rt.jar`、`resources.jar`、`charsets.jar`等 jar 包和类）以及被 `-Xbootclasspath`参数指定的路径下的所有类。
   2. **`ExtensionClassLoader`(扩展类加载器)**：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。
   3. **`AppClassLoader`(应用程序类加载器)**：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

## 14. 讲一下类加载过程？

![image-20240803165721901](./assert/jvm/image-20240803165721901.png)

1. 加载

   1. 通过全类名获取定义此类的二进制字节流。

   2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构。

   3. 在内存中生成一个代表该类的 `Class` 对象，作为方法区这些数据的访问入口。

      ![image-20240803170037439](./assert/jvm/image-20240803170037439.png)

2. 验证

   1. 文件格式验证（Class 文件格式检查）
   2. 元数据验证（字节码语义检查）比如是否有父类，是否继承了final修饰的类
   3. 字节码验证（程序语义检查）比如类型转换是否合理，函数的参数类型是否正确
   4. 符号引用验证（类的正确性检查）比如使用的方法、类、字段是否存在、是否拥有正确的访问权限

   文件格式验证这一阶段是基于该类的二进制字节流进行的，主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java 类型信息的要求。除了这一阶段之外，其余三个验证阶段都是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。

3. 准备

   **准备阶段是正式为类变量分配内存并设置类变量初始值的阶段**

   ![image-20240803170630818](./assert/jvm/image-20240803170630818.png)

4. 解析

   **把类中的符号引用转化为直接引用**

5. 初始化

   **对类的静态变量，静态代码块执行初始化操作**

   ![image-20240803170828813](./assert/jvm/image-20240803170828813.png)

6. 使用

   **JVM开始从入口方法开始执行用户的程序代码**

   类初始化的时机：

   * 调用静态类成员信息，比如：静态字段、静态方法。
   * 使用new关键字为其创建对象实例。
   * 使用 `java.lang.reflect` 包的方法对类进行反射调用时如 `Class.forName("...")`, `newInstance()` 等等。如果类没初始化，需要触发其初始化。
   * 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。
   * 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 `main` 方法的那个类)，虚拟机会先初始化这个类。
   * `MethodHandle` 和 `VarHandle` 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 `findStaticVarHandle` 来初始化要调用的类。
   *  当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

7. 卸载

   **卸载类即该类的 Class 对象被 GC。**

   卸载类需要满足 3 个要求:

   1. 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。
   2. 该类没有在其他任何地方被引用
   3. 该类的类加载器的实例已被 GC

   所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。

## 15. 什么是双亲委派模型？

* 加载某一个类，先委托上一级的加载器进行加载，如果上级加载器也有上级，则会继续向上委托，如果该类委托上级没有被加载，子加载器尝试加载该类。
* 为什么采用双亲委派机制？
  * 通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。
  * 为了安全，保证类库API不会被修改。

## 16. 创建对象的过程？

## 17. 对象的生命周期？



