# 内存模型

![image-20240803131152587](.\assert\jvm\image-20240803131152587.png)

## 1. 程序计数器的作用，为什么是私有的？

作用是记录正在执行的虚拟机字节码指令的地址。

私用的原因是为了实现进程的切换。详细的再解释一下...

使用`javap -V xx.class` 命令来反编译字节码文件。

## 2. 你能详细的介绍一下java堆及其构成吗？

* java堆是虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域，在**虚拟机启动时创建**，主要用来存放对象实例和数组。

* 随着JVM的发展和不同垃圾收集器的实现，堆的具体划分可能会有所不同，但通常可以分为以下几个部分：

  ![image-20240803132704964](.\assert\jvm\image-20240803132704964.png)

  * 新生代:新生代分为Eden Space和Survivor Space。在Eden Space中， 大多数新创建的对象首先存放在这里。Eden区相对较小，当Eden区满时，会触发一次Minor GC（新生代垃圾回收）。在Survivor Spaces中，通常分为两个相等大小的区域，称为S0（Survivor 0）和S1（Survivor 1）。在每次Minor GC后，存活下来的对象会被移动到其中一个Survivor空间，以继续它们的生命周期。这两个区域轮流充当对象的中转站，帮助区分短暂存活的对象和长期存活的对象。
  * 老年代（Old Generation/Tenured Generation）:经过一次或多次Minor GC仍存活的对象会被移动到老年代。老年代中的对象生命周期较长，因此Major GC（也称为Full GC，涉及老年代的垃圾回收）发生的频率相对较低，但其执行时间通常比Minor GC长。老年代的空间通常比新生代大，以存储更多的长期存活对象。
  * 元空间（Metaspace）:从Java 8开始，永久代（Permanent Generation）被元空间取代，用于存储类的元数据信息，如类的结构信息（如字段、方法信息等），静态变量，常量。编译后的代码。元空间并不在Java堆中，而是使用本地内存，这解决了永久代容易出现的内存溢出问题。
  * 大对象区（Large Object Space / Humongous Objects）:在某些JVM实现中（如G1垃圾收集器），为大对象分配了专门的区域，称为大对象区或Humongous Objects区域。大对象是指需要大量连续内存空间的对象，如大数组。这类对象直接分配在老年代，以避免因频繁的年轻代晋升而导致的内存碎片化问题。

## 3. 什么是虚拟机栈？

* 每个线程有一个私有的栈，随着线程的创建而创建。每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存，栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、动态链接、方法出口等信息，每个线程只能有一个活动栈帧，对应这当前正在执行的那个方法。栈的大小可以固定也可以动态扩展。

* 垃圾回收是否涉及栈内存？

  垃圾回收主要指堆内存，当栈帧弹出时，内存就会释放。

* 栈内存分配越大越好吗？

  未必，默认的栈内存通常为1024K，栈过大会导致线程数变小。

* 方法内的局部变量是否线程安全？

  * 如果方法内局部变量没有逃离方法的作用范围，他是线程安全的
  * 如果局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全

* 什么情况会导致栈内存溢出？

  《Java虚拟机规范》中，对了虚拟机栈的两类异常情况

  1. 如果线程请求的栈深度大于虚拟机允许的深度，将抛出StackOverflowError异常；
  2. 如果java虚拟机栈容量可以动态扩展，当栈扩展到无法申请足够的内存会抛出OutOfMemoryError异常。

  

  

## 4. 能不能解释一下方法区？

* 方法区是各个线程共享的内存区域，用来存储以被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等，虚拟机启动的时候创建，关闭虚拟机时释放。

class文件包含类基本信息、常量池、方法定义。

## 5. 介绍一下运行时常量池

常量池是*.class文件中的，当该类被加载，它的常量池信息就会放入**运行时常量池**，并把里面的**符号地址变为真实地址**。符号地址就是指#1、2、3那个，真实地址就是内存地址了

类基本信息：

![image-20240803141957321](.\assert\jvm\image-20240803141957321.png)

方法定义：

![image-20240803142114952](.\assert\jvm\image-20240803142114952.png)

（无参构造函数）

![image-20240803142138268](.\assert\jvm\image-20240803142138268.png)

（mian方法）

常量池：

![image-20240803142306513](.\assert\jvm\image-20240803142306513.png)

![image-20240803142349815](.\assert\jvm\image-20240803142349815.png)

![image-20240803142413758](.\assert\jvm\image-20240803142413758.png)

 ## 6. 你听过直接内存吗？

* 不是虚拟机运行时数据区的一部分，也不是jvm中的内存结构，不由jvm进行管理。是系统内存。

* 常见于NIO操作时，用于数据缓冲区，分配回收成本高，但读写性能高，不受JVM内存回收管理。

## 7. String保存在哪里呢？

## 8. String s = new String（“abc”）执行过程中分别对应哪些内存区域？

## 9.  引用类型有哪些？有什么区别？

## 10.  弱引用了解吗?举例说明在哪里可以用?

## 11. OOM发生在JVM的哪一块内存空间？

## 12.  jvm 内存结构有哪几种内存溢出的情况？

# 类初始化和类加载

## 13. 什么是类加载器。类加载器有哪些？

## 14. 讲一下类加载过程？

## 15. 什么是双亲委派模型？

## 16. 创建对象的过程？

## 17. 对象的生命周期？



